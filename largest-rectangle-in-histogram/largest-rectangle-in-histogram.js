/**
 * @param {number[]} heights
 * @return {number}
 */

/*
 * O(n)으로 해결하려면 right -> left 또는 left -> right 순서로 해결해야 한다.
 * 넓이를 계산하는 것이 방향과는 관계 없으므로 left -> right로 생각하겠다.
 * O(n)으로 해결하려면 i번째까지의 정보만으로 계산할 수 있어야 한다.
 * 그런데 i번째까지만의 정보로 넓이를 계산할 수 없다.
 * 예를 들어 위의 높이가 1인 블록에서의 area의 넓이는 6이 되어야 한다.
 * 하지만 이를 결정하려면 마지막 블록까지의 높이를 알아야만 가능하다.
 * 즉, 해당 i번째 블록의 오른쪽도 검색해야 하므로 이는 O(n)의 시간 복잡도가 필요하다.
 * 하지만 left -> right로 검색중이므로 이렇게 되면 O(n^2)의 시간 복잡도가 필요해서 시간을 초과한다.
 *
 * 문제가 발생하는 원인은 i번째까지의 정보만으론 계산할 수 없기 때문이다.
 * 그런데 계산 순서를 바꿔서 i번째 블록의 영역 계산을 나중에 할 수 있다면 이 문제를 해결할 수 있다.
 * 위 예시의 1번 블록을 마지막에 넓이를 계산한다면 이미 모든 높이를 알고 있으므로 별도의 검색 없이 가능할 것이다.
 * 이처럼 계산 순서를 바꾸려면 어딘가에 데이터를 저장한 다음 조건을 만족했을 때 계산해야 한다.
 * 이때 어떤 자료구조가 적절한지는 조금 뒤에 알아보겠다.
 *  
 * 현재 데이터만으로 계산할 수 없는 경우 데이터를 저장해야 한다.
 * 위 예시에선 1, 5, 6, 2, 3은 각 블록까지의 정보만으로 넓이를 계산할 수 없다.
 * 반면 첫 번째 블록은 가능한데, 이 둘의 차이는 다음 블록과의 대소관계의 차이다.
 * 다시 말해 heights[i] <= heights[i + 1]인 경우는 현재 계산할 수 없고, 
 * heights[i] > heights[i + 1]인 경우는 계산이 가능하다.
 * 그러므로 heights[i] <= heights[i + 1]인 경우는 데이터를 저장하고, 
 * heights[i] > heights[i + 1]인 경우는 해당 넓이를 계산하면 된다.
 * 
 * heights[i] > heights[i + 1]인 경우가 발생했을 때, 영역을 계산하는 것을 상상해보자.
 * i 이전까지는 높이가 증가하고 있었으므로 그래프 역시 막대가 커지는 형태였을 것이다.
 * 위의 5, 6 막대의 경우가 이에 해당된다.
 * 이때 넓이를 구하려면 각 막대로 가능한 최대한의 넓이를 계산해야 한다.
 * 높이는 이미 알고 있으므로 폭을 결정해야 한다.
 * 폭은 i번째 막대의 높이 이상인 막대의 수가 된다.
 * 
 * 여기서 멈춘다면 우리는 막대가 꺽이는 곳의 넓이만을 계산하게 된다.
 * 우리가 데이터를 저장한 이유는 넓이를 계산하기 적절한 시점까지 일을 미루기 위해서였다.
 * 그러므로 이 시점에 계산하기 적절한 넓이는 모두 계산해야 한다.
 * 위 그림을 예시로 들자면, 6번 막대를 계산한 다음 5번 막대로 가능한 넓이도 계산해야 한다는 것이다.
 * 여기서 적절한 자료구조가 스택이란 것을 알 수 있다.
 * 현재까지 저장한 정보를 거슬러 올라가며 찾기 때문이다.
 *
 * 이제 남은 것은 넓이를 어느 블록까지 계산할지다.
 * 잠시 높이 h인 블록이 있다고 하자.
 * 높이가 h이면서 넓이가 최대가 되려면 양방향으로 높이가 h 이상인 블록까지 찾아야 한다.
 * 다시 말해 h > heights[left]인 블록 left와, h > heights[right]인 블록 right를 찾아야 한다.
 * 이때 우리는 i + 1번째까지의 정보만을 알고 있으므로 right가 i + 1보다 커져서는 안 된다.
 * 그러므로 right는 i + 1이고, h >= heights[i + 1]인 경우까지만 계산하면 된다. 
 *
 * left를 찾기 전에, 위 방법으로 계산하면 스택의 변화를 살펴보자.
 * 스택에서 heights[s] >= heights[i + 1]인 s는 모두 제거 된다.
 * 그러면 스택엔 heights[s] < heights[i + 1]인 s만 남는다.
 * 그러므로 스택의 제일 위의 점 s가 left가 된다.
 * 이때 스택이 비어 있을 수 있으므로 스택의 끝을 표시하는 수가 필요하다. 
 *
 * 다만 이렇게 계산하면 마지막에 그래프가 꺽이지 않아서 계산하지 않는 부분이 생길 수 있다.
 * 이를 방지하기 위해 hegiths의 마지막으로 0을 추가해주면 간단히 해결할 수 있다.
 */

var largestRectangleArea = function(heights) {
  heights.push(0);
  const N = heights.length;
  let stack = [-1];
  let maxArea = 0;

  for (let i = 0; i < N; ++i) {
    while (heights[stack.at(-1)] >= heights[i]) {
      let index = stack.pop();  
      let height = heights[index];
      let width = i - stack.at(-1) - 1;
      maxArea = Math.max(maxArea, height * width);
    }
    stack.push(i);
  }    
  heights.pop();
  
  return maxArea;
};